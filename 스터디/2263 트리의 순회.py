import sys

input = sys.stdin.readline
sys.setrecursionlimit(10 ** 6)


# 이 문제를 풀 때 중요한 점의 각 트리의 순서 배치 특성을 이해해야한다.
# 문제에 제시된 예시는 규모가 작으니 조금 키워서 설명해보자
#        0
#     1       2
#   3   4   5  6
# 7  8 9 10
# 같은 배치라고 했을 때
# 중위 순회는 7 3 8 1 9 4 10 0 5 2 6
# 후위 순회는 7 8 3 9 10 4 1 5 6 2 0

# 이 나오게 된다 이때
# 이 문제의 핵심인 전위 순회를 해결하는 데 필수인 루트의 위치가
# 후위 순회의 가장 마지막 인덱스에 나오게 되는 점이다.

# 그리고 각 서브트리의 정점도 각 서브트리의 범위에서 가장 마지막 위치에 정점을 표시하게 된다.
# 또 중위 순회의 특성상 정점은 왼쪽 서브트리와 오른쪽 서브트리 사이에 존재하게 되는 데 이를 특정하기 어렵기 때문에

# 후위 순회의 특성을 이용하여 정점의 위치를 파악하여
# 중위 순회의 정점을 통해 왼쪽 서브트리의 갯수와 오른쪽 서브트리의 갯수를 파악하고

# 이를 통해 후위 순회의 서브트리들의 인덱스를 파악할 수 있게 된다
# 그러기 위해서는 중위 순위의 각 노드가 위치하는 순서를 파악할 필요가 있다.

# 그래서 중위 순회의 각 정점이 가지는 순서를 나열하면 다음과 같이 나온다.
# [7,3,9,1,5,8,10,0,2,4,6]
# 이를 토대로 위에서 제시된 트리를 전개 해보자
# 최초 루트를 레벨 0이라고 지정했을 때
# 레벨1의 왼쪽 서브트리의 노드는 0을 기준으로 7개, 반대는 3개 이다
# 중위순회의 경우 왼쪽은 시작점에서 (시작점 + 왼 노드 개수 -1) 오른쪽은 (끝점 - 오른 노드 개수 + 1 )에서 끝점 까지이다.
# 이때 후위순회는 시작점에서 (시작점 + 왼 노드 개수 -1) 오른쪽은 (끝점 - 오른 노드 개수)에서 끝점 - 1 까지이다.
# 이와 같은 방식으로 코드를 짜보자

def preorder(in_s, in_e, pos_s, pos_e):
    # 각 순회의 시작점이 끝점을 넘으면 안되기 때문에
    # 그리고 최고 레벨노드에서 재귀시 아래 조건문에 걸리게 된다
    # print('!',in_s, in_e, pos_s, pos_e)
    if (in_s > in_e) or (pos_s > pos_e):
        return

    # 정점은 후위 순회의 끝점
    root = poss[pos_e]

    # 노드의 갯수는
    left = nodes[root] - in_s
    right = in_e - nodes[root]

    # 전위 순회의 순서는 정점, 왼쪽, 오른쪽이다
    print(root, end=" ")
    preorder(in_s, in_s + left - 1, pos_s, pos_s + left - 1)
    preorder(in_e - right + 1, in_e, pos_e - right, pos_e - 1)


a = int(input())
ins = list(map(int, input().split()))
poss = list(map(int, input().split()))

# 중위 순회 노드의 순서 파악하기
nodes = [0] * (a + 1)
for i in range(a):
    nodes[ins[i]] = i
preorder(0, a - 1, 0, a - 1)
